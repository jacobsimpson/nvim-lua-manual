'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/nvim-lua-manual/docs/basic-plugin/','title':"A Basic Lua Plugin",'content':" A Basic Lua Plugin Quick Start There are a few different files involved in setting up a plugin, and a specific directory structure. I like to start from a working plugin and start adding my code.\nbash \\  \u0026lt;(curl -o- https://raw.githubusercontent.com/jacobsimpson/nvim-example-lua-plugin/master/install.sh) \\  mynewplugin Once that is done, you have a new plugin ready to go. It doesn\u0026rsquo;t do anything except print some messages, but it is enough to get you started.\nTo use the new plugin, add it to your runtimepath when starting Neovim.\nnvim --cmd \u0026#34;set rtp+=./mynewplugin\u0026#34; More Detail The vim file in the plugin directory will be executed when vim starts. The lua require(...) statements in the vim files will load Lua files.\nIn order to satisfy the require call, the Lua interpreter that is part of Neovim will look in the lua subdirectory of the directories on the runtimepath for the arguments specified in the call to require. In the example above, where ./mynewplugin was added to the runtimepath, require(\u0026quot;mynewplugin\u0026quot;) would cause the Lua interpreter to look in ./mynewplugin/lua for a mynewplugin directory.\nIf require points to a directory, the interpreter will load the init.lua file in that directory. If the require points to a file, the interpreter will append a .lua extension, and load the file.\nTODO: There have been a lot of Neovim improvements, this example could probably use some updates. Also, if the luamodule was named myluamodule it would be just a little more obvious that the directory name/module name can be changed.\n"});index.add({'id':1,'href':'/nvim-lua-manual/docs/apis/','title':"Neovim APIs",'content':" Neovim APIs There are a variety of APIs available for scripting Neovim using Lua.\n vim.split or vim.gsplit vim.trim vim.api.nvim_* Built in functions are available as vim.fn.* See :help lua-stdlib for more details. Lua APIs  String Functions  join stridx string.* from Lua strlen strpart strridx submatch substitute vim.split or vim.gsplit vim.stricmp vim.trim  Directory Functions  delete filereadable filewritable finddir findfile fnameescape fnamemodify getcwd getfperm getfsize getftime getftype isdirectory mkdir nvim_set_current_dir readdir readfile rename resolve simplify  Evaluation/Execution Functions  luaeval system systemlist vim.api.nvim_call_function vim.api.nvim_command  "});index.add({'id':2,'href':'/nvim-lua-manual/docs/communicating/','title':"VimL to Lua and back",'content':" VimL to Lua and back There are different reasons for having VimScript and Lua code interact, such as calling existing functions, setting variables to configure other plugins, or Neovim. Below are descriptions of techniques for different kinds of interactions between VimScript and Lua.\nFrom Lua Accessing VimL Variables There are a number of variables with different scopes. Depending on the scope of the variable, there are different APIs for accessing the values.\n Global variables (echo g:something):\nlocal a = vim.api.nvim_get_var(\u0026#39;something\u0026#39;) vim.api.nvim_set_var(\u0026#39;something\u0026#39;, \u0026#39;value\u0026#39;) Vim variables (echo v:servername):\nprint(vim.api.nvim_get_vvar(\u0026#34;servername\u0026#34;)) And for general expression evaluation, which can include accessing variables:\nlocal servername = vim.api.nvim_eval(\u0026#34;v:servername\u0026#34;)  Calling VimL Functions vim.api.nvim_call_function(...) From VimScript Calling Lua Code from VimL nvim_execute_lua(...) Starting in Neovim 0.5.0, it is possible to invoke global Lua functions directly from VimL:\nv:lua.luafunc(arg1, arg2) "});index.add({'id':3,'href':'/nvim-lua-manual/docs/buffers-and-windows/','title':"Buffers and Windows",'content':" Buffers and Windows Setting Options When you set an option in Neovim, the syntax you may be accustom to, as a user, is :set nomodifiable, or :set buftype=nofile.\nWhen using the the Neovim API to set options, I\u0026rsquo;ve found a couple things to keep in mind.\n The option may be a buffer, window or global option, and there is a different API call for each. If you choose the wrong API, the API call will result in an error. So if you are trying to set an option, and you are getting an error indicating there is no such option, try a different API.\nvim.api.nvim_buf_set_option(buf, \u0026#39;modifiable\u0026#39;, false) vim.api.nvim_win_set_option(win, \u0026#39;winhighlight\u0026#39;, \u0026#39;Normal:Normal\u0026#39;) vim.api.nvim_set_option(\u0026#39;wrapscan\u0026#39;, false) The option values are type sensitive. Options prefixed with no are boolean values, i.e. :set nomodifiable translates to modifiable with a boolean value.\nvim.api.nvim_buf_set_option(0, \u0026#39;modifiable\u0026#39;, true)  Reading a Buffer Modifying a Buffer Clearing a Buffer vim.api.nvim_buf_set_lines(buf, 0, -1, true, {}) Replacing a Buffer vim.api.nvim_buf_set_lines(buf, 0, -1, true, {\u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;}) Appending to a Buffer vim.api.nvim_buf_set_lines(buf, -1, -1, true, {\u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;}) Setting Options on a Buffer To set options on the current buffer, use 0 as the first argument. To specify a buffer, use the value returned by nvim.api.nvim_create_buf() or nvim.api.nvim_list_bufs().\nvim.api.nvim_buf_set_option(0, \u0026#39;buftype\u0026#39;, \u0026#39;nofile\u0026#39;) vim.api.nvim_buf_set_option(0, \u0026#39;filetype\u0026#39;, \u0026#39;lua\u0026#39;) vim.api.nvim_buf_set_option(0, \u0026#39;modifiable\u0026#39;, true) The name of a buffer is not a standard option, and has it\u0026rsquo;s own function:\nvim.api.nvim_buf_set_name(buf, \u0026#39;my special buffer\u0026#39;) "});index.add({'id':4,'href':'/nvim-lua-manual/docs/interacting/','title':"Interacting with the User",'content':" Error Handling This is not a tutorial on Lua error handling mechanisms, it is a discussion of Neovim error handling conventions.\nThe preference is:\n Raise an error (with error or assert) for syntax problems. Return an error message as the last return value if this is something the caller may like to recover from.  Also, when I ran a test program, it seems that pcall(\u0026hellip;) doesn\u0026rsquo;t fully catch errors. They still end up being displayed.\nfunction a() print(\u0026#34;one\u0026#34;) error(\u0026#34;this is something\u0026#34;) return 3 end local result, err = pcall(a())  Spend some more time testing this. Try the xpcall method as well. Test this out in a standard lua interpreter, to see if my understanding of pcall matches reality.  Interacting with the User Echo To put a message at the bottom of the screen, and in the :messages buffer:\nprint(\u0026#34;Something really important.\u0026#34;) This is analogous to the echo command in VimScript.\nDisplaying something there is a confirm API method in Vim documentation that asks questions and returns the selected response.\nA Split A Floating Window A Floating Window with Borders At the moment this is no native support margins or borders on floating windows, so there is a work around to nest floating windows. It is outlined in VimScript here and converted into Lua here.\nfunction NavigationFloatingWin() -- get the editor\u0026#39;s max width and height local width = vim.api.nvim_get_option(\u0026#34;columns\u0026#34;) local height = vim.api.nvim_get_option(\u0026#34;lines\u0026#34;) -- create a new, scratch buffer, for fzf local buf = vim.api.nvim_create_buf(false, true) vim.api.nvim_buf_set_option(buf, \u0026#39;buftype\u0026#39;, \u0026#39;nofile\u0026#39;) -- if the editor is big enough if (width \u0026gt; 150 or height \u0026gt; 35) then -- fzf\u0026#39;s window height is 3/4 of the max height, but not more than 30 local win_height = math.min(math.ceil(height * 3 / 4), 30) local win_width -- if the width is small if (width \u0026lt; 150) then -- just subtract 8 from the editor\u0026#39;s width win_width = math.ceil(width - 8) else -- use 90% of the editor\u0026#39;s width win_width = math.ceil(width * 0.9) end -- settings for the fzf window local opts = { relative = \u0026#34;editor\u0026#34;, width = win_width, height = win_height, row = math.ceil((height - win_height) / 2), col = math.ceil((width - win_width) / 2) } -- create a new floating window, centered in the editor local win = vim.api.nvim_open_win(buf, true, opts) end end For a tool tip This uses Neovim\u0026rsquo;s new floating window capability to overlay a window. The window is backed by a buffer containing the two lines, \u0026ldquo;test\u0026rdquo; and \u0026ldquo;text\u0026rdquo;.\nlocal buf = vim.api.nvim_create_buf(false, true) vim.api.nvim_buf_set_lines(buf, 0, -1, true, {\u0026#34;test\u0026#34;, \u0026#34;text\u0026#34;}) local opts = { relative = \u0026#39;cursor\u0026#39;, width = 10, height = 2, col = 0, row = 1, anchor = \u0026#39;NW\u0026#39;, style = \u0026#39;minimal\u0026#39; } local win = vim.api.nvim_open_win(buf, 0, opts) -- optional: change highlight, otherwise Pmenu is used vim.api.nvim_win_set_option(win, \u0026#39;winhl\u0026#39;, \u0026#39;Normal:MyHighlight\u0026#39;) "});index.add({'id':5,'href':'/nvim-lua-manual/docs/job-control/','title':"Job Control",'content':" Job Control I\u0026rsquo;m using this term to refer to starting, communicating with and otherwise controlling external processes. There are a few options available, with different trade offs.\nVim system or systemlist It is possible to use the Vim system or systemlist APIs.\nlocal result = vim.fn.system(\u0026#34;ls\u0026#34;) if vim.api.nvim_get_vvar(\u0026#34;shell_error\u0026#34;) != 0 then -- Error handling. else -- Success handling. end The drawbacks are:\n Neovim will be paused while the external process completes execution.  Vim jobstart The Neovim job control API is available in Lua like so:\nvim.fn.jobstart(\u0026#34;ls\u0026#34;) However, at the moment, it is unable to accept the second parameter that allows callbacks to be configured. There is an open issue, neovim/7607.\nLua popen local handle = io.popen(\u0026#34;ls\u0026#34;) local result = handle:read(\u0026#34;*a\u0026#34;) handle:close() The drawbacks are:\n It isn\u0026rsquo;t straightforward to capture the result code of the process execution. Stackoverflow Discussion\n It isn\u0026rsquo;t straightforward to capture the stdout and stderr.\n Neovim will be paused while the external process completes execution.\n  Networking, Communication and Job Control How to use Neovim to send a message to a Running Neovim instance nvim --noplugin --cmd \u0026#34;lua vim.fn.rpcrequest(vim.fn.sockconnect(\u0026#39;pipe\u0026#39;, \u0026#39;/var/folders/nh/lwpxl66111j103y85rw0kdvw0000gn/T/nvimNdff2D/0\u0026#39;, { rpc = true }), \u0026#39;nvim_command\u0026#39;, \u0026#39;:e ~/.zshrc\u0026#39;)\u0026#34; --cmd \u0026#34;q\u0026#34; --headless "});index.add({'id':6,'href':'/nvim-lua-manual/docs/basic-plugin/hidden/','title':"Hidden",'content':" This page is hidden in menu Quondam non pater est dignior ille Eurotas Latent te facies Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired));  "});index.add({'id':7,'href':'/nvim-lua-manual/categories/','title':"Categories",'content':""});index.add({'id':8,'href':'/nvim-lua-manual/docs/','title':"Docs",'content':""});index.add({'id':9,'href':'/nvim-lua-manual/','title':"Introduction",'content':" Building Neovim Plugins in Lua First To acknowledge, all this information is available somewhere, most of it in the Neovim :help documentation. I just find it easier to pull it all together. I\u0026rsquo;m not a proficient plugin writer, and when I do write a plugin, I\u0026rsquo;m just trying to quickly solve a problem and get back to work. I want a place to see examples and copy working code.\nI don\u0026rsquo;t really enjoy working in VimScript, so this is as much about Lua as possible. However, at heart, I am a pragmatist, so where it makes sense, I put things in VimScript. autocmd, key mappings, commands and the like. I don\u0026rsquo;t cover how to do any of that stuff in much depth here, there are much better resources available.\n"});index.add({'id':10,'href':'/nvim-lua-manual/tags/','title':"Tags",'content':""});})();